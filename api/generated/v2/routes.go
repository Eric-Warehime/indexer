// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"cvSLI2U3H2/+JwAA//96pwdUuUcBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
