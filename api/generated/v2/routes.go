// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/Y/bNtrgv0L4XmCTnjWTpt3FNcDiRTZpsMGmu0GSdoHr9FBaom12ZFIlqRm7ufzv",
	"L/g8JEVJlCzPeCbJxj8lY/Gbz/cX389yuamkYMLo2ZP3s4oqumGGKfiL5rmshcl4Yf8qmM4VrwyXYvbE",
	"fyPaKC5Ws/mM218rataz+UzQDWva2P7zmWK/11yxYvbEqJrNZzpfsw21A5tdZVu7kT58mM9oUSimdX/W",
	"f4lyR7jIy7pgxCgqNM3tJ02uuVkTs+aauM6ECyIFI3JJzLrVmCw5Kwt95hf9e83ULlq1m3x4ifPZNqPl",
	"Sioqimwp1Yaa2ZPZU9fvw97PboZMyZL19/hMbhZcML8jFjYULocYSQq2hEZraohdnd2nb2gk0YyqfE2W",
	"Uu3ZJi4i3isT9Wb25OeZZqJgCm4uZ/wK/rtUjP3BMkPVipnZL/PU3S0NU5nhm8TWXrqbU0zXpdEE2sIe",
	"V/yKCWJ7nZEfam3IghEqyJsXz8g333zzHcFjNKxwADe4q2b2eE/hFgpqmP885VLfvHgG8791G5zailZV",
	"yXNq951En6fNd/Ly+dBm2oMkAJILw1ZM4cFrzdK4+tR+GZnGd9w3QW3WmQWb4Yt1GK9JLsWSr2rFCguN",
	"tWaIm7piouBiRS7ZbvAKwzR3h4ELtpSKTYRSbHxUMI3n/6hwmtdKMZHvspViFFBnTUX/SN64o9BrWZcF",
	"WdMr2DfdAA9wfYnti/d8RcvaHhHPlXxarqQm1J1gwZa0Lg3xE5NalJZm2dEcHBKuSaXkFS9YMbdk/HrN",
	"8zXJqcYhoB255mVpj7/WrBg65vTu9oB56GTXdaPzgA19uofR7GvPSbAtIEJ/+99vHboXBbc/0ZJwwzaa",
	"6DpfE6rdqtaytMiu5ySiZKSUOS1JQQ0l2khLIZZSOdaN5GPu+jfSCMnhAguy2HVbiqI1+v4+9nzYtiql",
	"3dmSlpqlz8vvPj4k2GXMJGlZzhzptRKDmzILP9Cq0hnsONOGGha3qSqdYKHhB6oU3dm/tdlZOQGIw6y5",
	"liwvpWaZkXtECC8VwElFTD8+qoMECvJuzQhMbj+gMAUgLSydKcsdMe7kLSQQLz7MCV+SnazJNeBMyS+h",
	"v9uNBeYNsbcOd9WSdazAOATVvcNIwPRCypJRATDthMfMXtwwGys9QGNzy7FggiJwuDkpWMlgkw30wa/a",
	"KLmDzVsYmBNZ2duWteljhSjcsPi5iyQAMYNyaryTPZsu+Yab/nZ/oFu+qTdE1JsFU/bCPcszkihmaiXg",
	"shUjOdzZooXyFV0xTZjliByFbJjHUiwhDVGM5uthcoRr2kOBNnSbKVmLYoIsaYhUMa/WFcv5krOChFGG",
	"1tJMs289XBy2nkbCjZbjBxlcTphlz3IE2yau1aKn/QIXFN3qGfnRMQ34auQlE4G3IJVkpFLsistah04D",
	"a4Spx7U4IQ3LKsWWfNtf5Ft3HJZCYBvH2TZOrMqlMJQLVlimB4uWhiG1GVxTNOGhsuOCavaXb4cEp+ar",
	"YpdslyS6XQDA7QRldW2/YN/xXYQZ9iD1RDhE5hrD3yjsTYI7aJQh2UgIR/arIyppw0Cr/wTTQDw3qqXZ",
	"rUwEOIZnb0NH0Znp7rQRzVcZjtjDEr56Z3nxkpfAp3+zyOFvttaWL7Xv1nNuzVeCmlqxJxfiK/sXychb",
	"Q0VBVWF/2eBPP9Sl4W/5yv5U4k+v5Irnb/lq6FD8WpMmA+i2wX/seGkTgdmG7aam8J9TM1TUNrxkO8Xs",
	"HDRfwj/bJQASXao/UOgqh2ZO6cevpLysq/gk85a9aLEjL58PQQkMOUYIgWjoSgrNAFyfogTxxv1mf7K0",
	"jgkg5ZEQcP6blqB7NGNXSlZMGc5i+5z9738ptpw9mf2v88aed47d9LmbsFH3zBAPQ8ylxtEupFmOmqEU",
	"sKlqgzw9RRYCHv8c1tads7kWufiN5QYPqL2MB2xTmd1Du2C3dv29UlId48gastGTu0EKwO2maM98tmFa",
	"0xVLdjbS0DLrifvJcVxb1BFGWrQ0hSntBkfsXI7fyJTLeCoIs4dPPBAHjnJ+9fg8GHyevn5JmCgqya1W",
	"BqRWVl43FEj1LC7RhRV1QfgDHdkgZLFtzlhhISu69OOhiG4pbxORpauH3SHyoCiXgUjWH/lH7ZTkiq64",
	"gI3PyfWaCbKhl5YHUCHNmtkr+r1m2nihDpkdynnBmuwkQ6denc1SZDKByPrWmNzc2iuLIG9BuTnGFXdw",
	"7oC7Ti3pdPPh5nsHe0wQWB3p7kfN7BcXP9Oq4sX24uKXln7NRcG26fu408su5SorqKE3g9HVc9s1AaCf",
	"Mgy1XRjHAqDjAs8Bt3C/YtSxjuvIyHYjGnuirAmsuD1RtULf32hJRX4UdrpwQ02+4R+44LCIv6Nh83TN",
	"/prDUR7jit3pHgWRg54wDYVPl5vC4eDzufXVHutKJ13kPZsBYMpjHNLHAvwTxB8X4v9WyvzyRnc5dlUw",
	"6p6Zj2VD8vJ7Z9dj9qFb2F/exGYXsMSAzfjvjJZm/WzN7uAwo7H3HOm7xkp6hIO9U7SKDLr79h/tao9A",
	"3h72QEyIptGf+ul9OkSpdeTTaXnrTrsUffod68Mu+YN3DMSW/0SAngumbRlKDaEu3gwddhfiQjxnSy7A",
	"//7kQlg6dL6gmuf6vNZMOSXgbCXJE+KGfE4NvRCz+bAZvL0SCClyq6nqRclzcsl2qVvAWKe0yaVcyYuL",
	"XwhYp6PogigCyvl0Gy9BH+RwgsxChqxN5iIHM8WuqSoSS9fBowwjYyjW2Kxoppa1Qce3i0x046fRIGXf",
	"T1mcyo69SSeinrhohyXZ+/2nNM5VTK8JwhepNdPk1w2tfubC/EKyi/rRo28YeVpVjdHy1yaGyi4afFVH",
	"tYDCxtHbwLZG0QyCP5LbN4xWcPtrRnS9gTiisiTQrR2qpeRK0Y2LI+kGgY1cAK5jGi+Ldgibe4u9Pswj",
	"YbB/g/YTXCG0IWtW9sPIDr2vSIu68XXt0cRGInQvLn6G4Ft/MyEqbEW50J4raL4SFglcXOOCkdxKAaw4",
	"Iy+XBKjavNXdRdc7ihlIB9cYikje2T1CuAPJqYAQxaqA2DAuCBW7rp9VM2O8V/sNu2S7d1G0xIFedxda",
	"RfewxKK2wwW22NwwuaaabCR43HMmTLlz0VoJ0EwvpubCYNhI15WXIhqANVFQnkWcmIQMxDNGMWq0qsiq",
	"lAtHaQKIPgkw6vsME5XXdgH6CAQlqTj1PJWJg6AqcRCIiEMhnYdv1I53KzQc3d6NQW7JlYZIQEYdj6Ax",
	"itwA8lyYYn8p/14zkMqkgnC9Nkhpj9IpoA9RSPNZRZXhOa+mWdFx9NetPnaQfaw9yczlssuzeyw1yUKw",
	"cbagOs2+mf1iIbDWGMJq9+gJnZ8JpWXYwRmBkCOHqosSolqDXxzvmCoIt/XbxsSAoaWl8YIp0chUfhnt",
	"E4mFtzXVPvIW4sY9iZgk5gwA7zt7AADAFm8i6I3lVm7nLdkVHTr/4Winl6KwtIPpdhRyiGXybKUfBe6D",
	"BjHhy8c8+UAnH91k/7XQXpcl4UtSi0shr61wfEj80nxmJb86fUlSgORncW6Fx4GNPfi4Bf9JR9dmV/Wv",
	"5bLkgpGM8HAGEBzhQvxlzjGgusFPNwezisFXxMKgHWDyCCngjpZdSVniwOSfMsZYsTpkkYJxoDHUjw3E",
	"JvqbpTW8wWCaPkDmnjRYIXMgz+BBS1h2gpp+OCSJp+0HnaCdfStBhvUgFtmaiZMC5ci04+JD6hg0bBqZ",
	"eTPvSErE9OCiQ3Z+iwV0rY8hDNNpnns1xD5jaSjsvAl0RWweBLrOzSdvZOCs+qaCENv0uss3kwaBViuC",
	"TRZOwY3koxRNtECdS6GZ0DVkEBmZy/KsZwnQrGQgWmQtVp5ZrT+pRDCgcG99t8hKQB7wpZXpH0ayg2Ir",
	"rg1rZfmE+OMmvHoHB11RY5iyE/2/B//95Oen2f+l2R+Psu/+9/kv77/98PCr3o+PP/z1r/+//dM3H/76",
	"8L//azZAtllWKSmXw7szlVra/b2RMpBF6EigY2ub976DK2lYBhJidkXLgXgX2+iFBu31BQiTSY7dumyC",
	"SWp8wPYH016yXVbwsk7Dq5v3H8/ttP8MBh9dLy7ZDuQyRvM1WVCTr0Fwa01v24xMXdK9G36FG35Fj7bf",
	"adhgm9qJlQWX9hyfCV50qOwYOUgAYAo4+rc2eKQjBBI49XNWoqtlOHkakbOwDc/GzJw9ZCr82GMaS7SK",
	"YX6EIyX30o4wGt4FhKNBPhg3UfKb7u1oqoYJ5nfkB9E01zSo0HeuSca7i7VJN0panXQfb7G9/vBTt3es",
	"+EG4vUMMJSgj9QAMEMcNtge4ItttP4XEyrje/ozYEsnqmCEq4r310ajJUZx2MV4EcSmTsg6stDPNnQEg",
	"S2gCuPcULJKlkhvAvL44GgEnH1CJWyDYsJzOrK4URx9eLPGEFPG9LixGy3+w3U+2Ldyq7Y3ZpVxMRZnG",
	"QgA9CRdGHuFqbmeMT0G+G3Ev5GNM7BDYQ9EGtIi2nGsHYkApV2mFv1yB3CFXTaJdDA4LZtU+tmV5bZoc",
	"y45BL9gc71ea7Bov07lRkd8UK4iMyw9wUG6sPVf3OtDJu7w5WlVKXtEyc96mIRqv5JWj8dDcO6fuWRxL",
	"o9m775++eu2WD34NRlUW1JnBXUG76rPZlZVLpBogsb4QwZqaYEPo8n/nbeK65aG6hvz1jsZsJS0HXEig",
	"G+9jhL3OY7X0cvmB/ifnKMUtjjhMWRX8pY2hG92lbRcpvaK89BZmv9o0U8HNNXazg/lKPMCtXa2RPSU7",
	"KqfoYXcaO/ZQoniGkUT1DZZL0ES6hPSg54JyC+ZqANAN3Vm4QetinySJepNZpMt0yfO0D0IstAUJge5z",
	"25hA4wE12Y5oeXF6rJpHY9lmeoK5rbPIaI7kYfrw06GzW0gX31ML/nvNCC+YMPaTAlzsoKfFRl8D58Yq",
	"UMLJhrVy7lEJggkPUX9c8ZBbbS6MchMlyOo1/Undrbn9hLu7jf7TWIf78h8sYlz5iSMhest9HiylHoqC",
	"xZ2KltP4gICqeMaelDESDOWQz5GKWnAXUHKD29lf4s0rWq7ITJpcHKRHxTVrbqU96Wyp5B8sbT0Eo+t1",
	"f/poYuydHnyyFtTBmwFtiHcqWN3gqkLVn9suKWjPt15Ul3cGN0pT/6+5pEGkGxLbY3dPOxRvgLAD/kUB",
	"H6CgenckFYhwz6COYEtjSqNtHKN5juM3aOvW3Ldr0OsFzS/T0rNd09MmzKnlODWS+M6hnlP7ls5IFDEV",
	"2rrSSBVTG27abKBRzG4qCeO0k2XgRuQFqIqFXVdWrdQyMUwtrqkwvsCVI2iut2boebK9rqXSBgrVJXdZ",
	"sJxvaJkWiQs4/XctIavgK46lqWrNosJKbiACpQcQigquq5LuMJCsOZqXS/JoHlE1dxsFv+KaL0oGLb7G",
	"FguqQVhpTFe+i90eE2atofnjCc3XtSgUK8za1fzSkgRtBSw/IX5hwcw1Y4I8gnZff0ceQOSG5lfsoT1F",
	"J4LOnnz9HRSjwj8epYk81BYcI7oFUF1P9NNwDKErOIZln27UNBXG6rDD9H0Em7DrFFyClo4l7MelDRV0",
	"xdLxkJs9a8K+cJvgxeqciyiwbB4IW4Sb9PzMUEufsjXV67R8gMsgudxsuNlYBDKSaLmx8NQU9sFJ/XBY",
	"gw8pfFiX/whhMhVJ2/Xu18aENXJSu4Zgpn/SDWsf65xQTXRt19zYyxxBPCOutlVBpCh3kUUTzsbOBQKK",
	"FTbB7rwkleLCgMZcm2X2f0i+pormlvydDS03W/zl2/6S/wYFwAgTubTzi8MWfu/nrphm6ip99GoA7L2o",
	"5fqSB0KKbGMpSvHQUfk2Vg5G7qTDwj1F72YFjA89Vd6yo2SD4Fa3wI1GlPpWgCdGBrwlKIb9HASPB+/s",
	"3iGzVmnwoLW9oR/fvHJSxkYqligc1KC7kzgUM4qzK4hQT1+SHfOWd6HKSbdwm9V/XLe/FzkjsczjckoR",
	"wGzL/nHYn+NtD6nYUl5eMlZxsTpf2D4oquOoXSF9xQTTXA8z0NXaQo79bFleZBGBocmClVKs9P1Dul/4",
	"gF95xYAmvXy+b9W9gX2JzgyaDh+MbWeneO1LeuLQtv3H4EghtHlvHu8b13Y4EtmyMcxleeYyTzDqp+2B",
	"xf1eU7CTM1GgWAfkb025GAhPZqwYiHxjMONbqQzH2BPGPkIcm+Ebpg3dVGk2C4ZjxETAarvQ0MVqI5rl",
	"UhSaaC5yRlgl9XpfwuxAotdWwGQl18hy4mKbuVRYMA5kCiM7yYxTUy1G0zbba8yUlGZooSB8xPm2UhpC",
	"a7NmwoRQZgb1p7s7wWQM0DiQoSDJIj9YGu/rRdKy3M0JN3/CcZQLH6Rkw9RlyYhRjJHrtdSMlIxesaYG",
	"PIz2J03ebXmhocJ7ybY8lytFqzXPiVQFU2fkhfMugxaEndx8j86IS0NzodjvtgK2V0iGKlK8T9ymj6gP",
	"vox4x3NkoN2foUK3ZuUV02fk3bXERegmdVdbIaTVY1EbTGEp+HLJAE9hO6A8Qb/mQ7QmqGYPNfXDsG5P",
	"HwHbtiID+XhAiTRoqdiKZ9iIuLyPtoOogxob1Fg9QJWsWDE1R0MqHDvfsCZV28puUpnGYLNkmA5hKRsX",
	"RsmizhkmCL9twWO0LN5bUqgDHXn4sSCje0ygWac3tniaahVyEHAfoZglZHuHcHfsiimyYExEAz1AohOt",
	"SxuqIDQCIiXcVlnxME2c62qlaMGm+TWBCP6IPUJiqx/hSh42wE+2fVdsaskmLY6f5tJR1LnlMjEtT9Gy",
	"QdHrzVCe0Assxq9YiakaUMcd2s57gtWSsUxzkbZ+LhkD2k7znFUWnOPnkxizhAqFWCAVkFnqeau9YWH4",
	"FcMkkhFhIMtpmdclxoOOcPrrnJaq7UYp2dJIC2DxqxqNSZDbuRYQj4oF0HE+ZQlg1ANKalwxtXMtUHvy",
	"9cYtcqiO77+frJWV7IqldRpGMWfr7/KabKjYhbuwUzTLmCO+AKqElaOsAo5lvO0fnWIXLR+RyUHd+CLt",
	"VQwcbhHfc8UUlwXPCRe/MYfNgSx5iMGHC6QwXNTw3oNizbqRTxBIP+ummPUhQA0l0dsP7WBywa5bt11E",
	"8lw79Fobeslw2T5RzrHGqXeqmOZFPWDKVDRvr+wwYHTI+4Yadq7C1eojwWWHQgUkH0O6Lix3wKZzW/1T",
	"GqRTLeI7hVjRkKlCHKFORKO66hy+5YDuI430FiefnR7GvmJKt+McIxsg2+4Z27ZojY81S5RE+8Lhs2Q+",
	"jEUPzrdDctzAnBe+ML0U+jMXR5E4wYGCLmEB+pqbfJ0NpHbYttgCU2M6mlZ/ShQhAAvZcslyM2UNkCOA",
	"73cMrgI/21U8Z7SAjMcm3QMTPbpLefBPSezQOpJrhOYghTZiDYzy8ICCnAFC9gH/T3Ii7F9J+B+4SCeg",
	"gRdk3N2nzZ7YxgFPk15LyY5pOJUQtRrhSCU1LdMeHj9pwUq6G5sSGrQnDYKtd3Ihz6GWh1mGglGy6fDj",
	"aGqHZ2OT2ybdDQf07GNF/D5A9ya/v6LlQBbKG1Yppq3ASCh59/3TV86XN5SLkg+mTlHjkoYNJYN5/h/m",
	"oPCkSQSGi8F399xY0o45FCKGEWL2c6/3zUILhuphRQfqIw77C/qHD4gnFeXOUd0k4vRP1iVn9dPlpgTV",
	"Nxfc3YRLeYJBUjuJq6T1oyHIGj5j/ZRQO7+/+MFicsUiC/GeqRdg5jNXDC6ugLU3yJvrbMNXCohOetSx",
	"Rw6CjJ5ImkNml3iLzBGWYW7YOffWxjsrbpbXqFJ+5tQd9WrTJi5K801VopPVDWX5aytv+6DEsiYW7O5D",
	"C48dl3XnkVXsxg6+4wdU3XQt+xPTx8Oo/iWeyU1VsmF+UKF7HJ/kQ84JFTGix9e8qUXmea0aG1w3UOon",
	"WnJ8FUhDVQwhZQVlMCrDhf0P5GjJ2uD/GVX2P1ijqf0/hKqoWIYdagb3wsXMVVuStfEh2DPLsgtUGFzf",
	"VDGNG+Z5TjIe93lNgiKOBn+3eDzcTIkm7yag3WIlfFnBlzhunuBCIFhD+780KZhhamNl17W8Jps6X0Oo",
	"OF0xHzkOEShgOO1M1BrdB9O1MyCc81FXNMeBMECppGrFFHExQ8SVpg6BRxvKO8+tdcMCQJWlKf67L569",
	"/8wgSEtRVHsibN4v45LtzlEYgN9vQDiGg+MHFgYh8ne4pFtF2sfJGnvg9bIlR2HBtVZ+S1j+EeUpuz6H",
	"awfKU/00lKnbg30AOtSa9fc53dkUn22CVDR7m6oM9A93WIY3iykyfLpyku0OSgQeCFQzI7BU8uvXvxLF",
	"lu6V16++ggm++mrumv76uP3ZAt5XX6U1sPtSH/CM3Bhu3iTEtEv6dt/ABYKmoSaNe6Q2l5uNFGBoKsuO",
	"l08UBOKeNLxaKwgTV6yUFUu2xgOOLh3yWxRb1SVF7xYXgqlWpymBy5qvBCvMVmBExFv4891WpNrGrB5a",
	"R8eRKvkavcRys1rIndp+GDaOD73fdMQmxLsZEUNBbzPiC4xDDSPCUEumbjPmOzfGhDKbK6Ewnw8DsbkP",
	"SwIhDW+48zClD1Xy5Td9wHXw4LLfa1o6D7UAf/A7CDrOL5nAyprhiX0jCRO6Vs4hbNcK49mluGFkzOB1",
	"0+SmNTazsbp1CozlwQ7vwtAggB67WtGjsJcjx8tR2fZcrLKRXJsckm1cQ59MCRau0RKKdnALhGrDiolJ",
	"9LE/DBLKfP+B4ZtqUc1zSOlUq+hhXNEvOUEevHz+kEA9maHKHtE7p/u3HResmrYijG3sraWbWnfIKpaM",
	"DTkhO3EbZMkG7Nn7yiItr5qKSNCqazjeu8qJgWh/pxpKHLnmzmH+iUaftRbpHjntDxWnAh9cNmc+WylZ",
	"p4OVVpie3gmjBMUAhC4ModFr+uevH58//vNfSMFXTJsz8m/IFULm269G2L5Nwpsqh61iqgQWFvJPUR5y",
	"cRLRnGt3ob14GO7iJWCY+7/hm1RrmM9ALsnMNhXT9bIns5DKBZdA6mREb1rG+mNEcnFhFEXim8nlMplO",
	"/C/4vTElKU+TFevf+gSqjM8I31Aq+Ae+QfxhPttTn6y8CqXJbkZ4SjZUqrbcJtDnm8dZg0Fn5JXtTZhY",
	"SmU17U1trAzAtpBWhLbOlpQKuTamKdsNaTbiD6YkGBIEkSJnPR7Io8OG2BCagzyvXYCTXUPIGw5R6A/e",
	"gjQzx0U+RD21j2qkFoaj+GOP8afoFCvLeOyi/73mZQIKKmm/63gdcyIkwQcp4pYYydfkjOGaXZx2C5Du",
	"F83j2glF2k5mIaHAOjRNyaHGSpGvqWgq7O8vUNOHyUNezm3T/i6aH7OQzsg6P24lHSEHglqEKxdoFRTI",
	"3goWtftdcEV3GybMDSnfa+yN8TJQYVqNawBqQAPwvffV675ku8zI9Nj2Y8geDqoW2E6R2kZ7nA/oPSEy",
	"wL9N0MiuiEFWRFjWEHMZhal626lT6YIN/pLtiPKmgbgyK6pNN9CykC0anspuesc3rNFLUJBLiUB8EktE",
	"9TKt12LAPZLsP41sJwwzDhV6ACqw7zhMhFs4AGzfhj4Q1psNW9J2FWuHD7TKkbfjZUHHPyPPQxwz+Fow",
	"oq8Jbkb7U9cjg9nAITmbK2+nosrbnMFpc3Hxc4XRFAnEdQ1QlrFt+lKNa0Lz5So8apIw3Phm2yVTTbuU",
	"8cS3XKo/moZ9u41v1n8Pp0V5GpdSRXczL5bN5jO7YPuPXZD9d6n+mMETMGXflZTGIXfNGUyQiI2btRXH",
	"liwXkKGBlj1GyNFyny7iB5w2EWM71EIY27WxwEHzwzNalu+2AmdKBKA0T+GnXI5YQdflcgQiaSmp8zp6",
	"w5FD0NhBQvPcSllFEysarfNPmnTrNGEEab9SU4uJH0gkE08WBXCjajW4b7AZ9SVBnhOqVvUGbfp3v789",
	"OxisTsoLl0bWL7HppCbE9FqxgkjlEkj40mUHDdWImVg3D596eiVXPG+ksyZ8dQDS51b/YJWr1iBFlgeH",
	"uGVVVskzklygI/lidkZeYrC5YrRAmqm4YakKbq39Q+brNYOa9B6is3C7UX3OM4tFrQp5GiBbMXjRKVGz",
	"8XOtCUgrXQ/c2BBVQsGmfUkf4Yae2ZmaWux4STkVQprP6J4OrAnYedMuCv+oqlAcsGTCP62Ioi8MO2Am",
	"lYrxlRh7h2pJPSPQ3etKsoM2lXJJbvHF6x6XCBLxzYgoOD9wMHxuhhaZFOUuRV3jhMYOeQ1nMfoYVUhx",
	"1E3IkHa7jKrpTNuiJzOvox0CYIPW/Pq4+7tBCcdb123sDNCiGvv6tuKiRp7Mx/yq9tD7JLPI0TgqmWFp",
	"l9JuHOmTYpnnn55iiQKrvtRNmNWFeEr+YEo6fTEMZRGiMU+71H+XlXuW6BRKNOlet+6UB5bAws2PSIeD",
	"peUuLn7e0p6UAWu6hXxxsyqBe+/4xUAJoviOvbfK1Ry6ZW0xnHHkYIeeWr24+HlJi6JTjSUOvUIiE6qJ",
	"4Gm7WkwALPR6oOzR6G0uR29zZPxW6sa1V/hGnsPyCiImyVz7E8ceqXDU4dDKpkZdf+opyB/895NAwyu9",
	"twUOP+sIeIxUjqQb0MmehqLAbnEyrO+MOBLifN3+d+VNKeXSUzPvHvMO3M57ZPjGPtnQ6qh1KfcSj2jF",
	"w25/Nuj0bxKiHGP240W1HmCAJrqg++rZ7Z5X9KOnbxC+dtNgaFwIpnlpVbEN5HA1KmbiclwBuSAWNpX9",
	"MJAC4h7i0HAdzRCfNSEv7ci0vKY77U2lDWAND+dPFSvGJMx0cZIn2nfTZ6NycIy9YTmvODwe26aCAcaH",
	"DYwDj/eiodISHcw+41fBaOFiw2lTkrHt/PK+L1dcjkYMeu6OmZZtawEO7I3Bts0zP7bfUbjSiJ/tT4RI",
	"FegMR7qH5jnv5Cixc5bCQ2kc9kIih9MMUzfRfUhowC0ibCN7aT9QddnigVS3H87EJIjWqC0RI0pduMHT",
	"Zs6Z8Lp5uwlCsYNp/yem0IH5hopCbsiLWiAUPPjpzYuH7kF9D2S+7IEFPreST/TVs0ot3c7fdt4685Ho",
	"6NNYcW1Uwm756b6Etuy/hJZ4D8zu7lhvoF0WH+kNtLL3BtrNdzr99TOPMUNvn32SALRHk/AOznHq6Xwx",
	"h5JP1w3pp5vpZuIhSodN8kJUQMDep6931WH8txKyWo8NU0OurfShXc3SRthqB3U21YNFiM2M/Ah7gz7b",
	"4w08deLkLJgEih4m3qjV7u1jz1uiV+7xpSqselxGws+yFoXuHGHz+saIB3RU9nGij28z6kwdEgqmSgJv",
	"Y1dpeyXginSpIOGN5e4DO1CJFmvOwjvX+MRyt4xUc5SVkle8SL17UcoVzzVaYA712b7yfT/MZ5u6NPyG",
	"4/zg+6ITOc0O+cqxQlFQVRBWPP7zn7/+rtnuJ0au+oeUDLBx23JGRmp43pZjw+4mEDF/lWcr2SdZg742",
	"tWpcD8G3Nofa2U382mEuMlhIer/RZn2IxmJHaATq0ortpeHNT3P725rqdUM6o/rnUJeeEkevunF3kPXz",
	"cR5YipAiu1VoRAc9hghHgySfAm503h/j+WSS+ENESfrlwd0W0exq4cWnQsJZVyWzsl1DA/t4k6tdZeS5",
	"vxpk+X7Ot7z/jEg8XvrUoQHUO5VWEsECCVaYbCQuMBA0q7pBfG7vfN7G60qVYVwrpu2K0vE0a3Vx8Uta",
	"2ByqGmCly3SnDwfe7dvOmbZPHM9tUMKtLnER96yzjcPA/S+pf+YfIGR7CdJYLoWhOciNWIB79tQZzGau",
	"3vNsbUyln5yfX19fn3lr2lkuN+crSDvJjKzz9bkfCF9CihPBXRdXKdFS4XJneK7J09cvQWbipmQQwV6w",
	"LVjtAmTNHp89wvoBTNCKz57Mvjl7dPY1ntgagOAca3XMnrz/MJ+dXz0+j0NlVsmHrRhV+RoVAdf2DHLh",
	"GWo3L4vQ6IVUT/1wzu2BT/s++XnoER+Lsvbv32umdjNfRT82AzXOuD567M9yRjOFxhBMUyvMG1fwjj8K",
	"cZGnGZ+eY1dMEI5iX8k3PDyeoaxS67h2Ys3Q9sAFNyW16IpF6z0jP2oW1a2Ul5AEguKmDyn3ZRdDp4GF",
	"2SFS62pAvp/ii6fmRF2I8KPCW95XkPYEThMRhY6etWrCOVOte0TDlezId6QWpZUvvPsBvIY6bA3KBWI1",
	"i5y6E3D5Vj5uVQ/fgJ8kcyvM7AoPvBFXWR10I2AmLtIWrFxOdXIwPg/lR+K4gXnzKJkz1M9JKOjRsTDP",
	"nd/fvzncf8oXowqGNuyCgDNalqltRr6m7ja/37ptNtCPu9V1voYIle5Ce48Mw/sbrlxA88AOns3c9Y+i",
	"BnyyXIgWCC1F6wAn9LHHwbZVKQs2e7KkpWbp42G4ydbRBAHBB2Li2bnAiE6aoMYYTJ1F0QGzVoqjTlb6",
	"6AoN2uyAZltGNjsU3Ur3BtInimt2ilshmg+/jHzr7uEj2C8UXLXYd8l2Q4tpspSHydzeoMrxz0PL9wzG",
	"hzQ0z9hg3UqoZl0xBUOKHLwqGsiEN1kisPuomoJruijhZQe0R7RCMgYpQSi2e8ANxDVnhjlxNxhlZIZf",
	"4DUWqP4FKPb40SMvNDkbYzTa+W8apeFmwOEg3kOyclII6EsZjmY8hyrU6PzCe71GYWFT1WY4QGBrMmDR",
	"/ZF/1I46VnTFhQurAcvdhl6CgU5gfpaLavPY6RPcLd8PLhknKTiImWBAa4Sx9gH8khRy2yt/ANEtD+0G",
	"v73dPY4UENvQbeZOOh3oNVaiDR7tyHr0OR0whm1D+NtQixZpn9JucMTOXfiNTDn6p4JAwbtQSy9Ql1hi",
	"twoBYaKAx+DmLnS18sy89yALiKexLZttc8bACvVhPvvzra54sLLf8PXd4njexKfiKgOC3kZXVtWYaVBG",
	"Zr986Kg45+992C0vPgzqO6+kvKyrYDiPn3jpqT3Y1tGdv+2AiI6qPcEc73kSkFyrnUUUNyxyFp+RUTU7",
	"SIifyqGOyFFOwvNJeL5j4flOZIwDJIs7lCTS3PvEvE/Mew/z/vbRt5838/7Pkj9KkAr2yB/nKdAfFUhE",
	"FCXZZTAedMqdi9gIiUVY6GZEbHlaVVBLAcKh9KckwBxdP/1S5ZWTWfxGZvEjixodfD/ArtHM0mDqycoR",
	"pUt1DvajSkyfBDs9SQSfo0QQxNGPIgd4ne3T4f934iM+8fwTz783nh8wehqjj5/vOPF3z9+DdenE1E9M",
	"/XNj6olyyIexeG/GTVt5b8Xyn+HQT+OlnfT/kyxwkgXuRv9vEYBDVf+TQJCoj3ISC05iwectFhyu8weB",
	"oOMkPooocDICnBj/ifF/dCPAidmftP8Tm//82XycSTw14rBbLWKEa7+Lh9/DtE+84Di5UdETUXaWJd86",
	"iuvLIuWy87yogMfnOSsHj0dAIRIY7OAMBkwpH0pgCF/fJyf21b7jSY9QoTx1bHz1blfZcyghOvE3e1oe",
	"AuumUEYITvU16EOGKNSH13xFslCvwP6ywZ8gB/YtX9mfSvwJsu8x9zi1d81Xw5vX0G2D/9jxJm3SYXK0",
	"kXbhgcXOSeLpu0iLsZ9khK+fkhpiNY0l5gPGU2+4yEanDw2OsoQFW0qXBxWtgW73rME3ODR15k61Er+z",
	"aE8rbimv4Rt2Rn5whIYK8ubFM/LNN998RxDhrZaC4DK0YRwS39eIFxcIRkFN+DyF/Lx58QwW8DZEdk5q",
	"tfdSA0Qda+cw4qe38S841faLTHv8mBkguGtnTnAaIj44NC6ehGeJRq0Px9WavxBtdz7rqgi3f2Gwo/W0",
	"T7Iz4ZenR/9HK6FTnMxxQY+2J2WopscB/uG799m+AAUC9YfWew0B6VBiCFV7m3JzSYKOzW4meJ/MxyeT",
	"wclv/CX6jf+j86Wjczp/3ybW+/Omo0fbhoyXTZN0znRKJO6yjL1i8Rfn/bszsnMgsbm/DNlbuoRO/pTP",
	"RJTtEaFz/7byREpEbPsJ5OiVXOmPQ5JOotZxvDMf2QL/hZrDoVp2sCv1HlTEOl6uBPq4OuZeU25eQ7qb",
	"cl53xiuHHy+teLHtPA1MuCjYdqAa/F2K6KVcZZ78H56CunpO0y/efw6SP5LqW0gOYzxrPJgvNrxAy7E6",
	"qpMC8U52iBNzPIBbtUxn7nHP+zOa7Z/djj64W9px3B1hvlpwMzSf/Ta7/0jVU+jhKfTwpGfep7ELLvn8",
	"vUfP/QYu96jk/rKAtuF0bTJ++O5k2rpT0xaQuam08B4LvsGUJ3Jzssx92pa5LsU8X9CSipzttcih6K3x",
	"fV9fCO96LYGguCKVQGBGKaqf7KQbnXSj05MXpzi8qXF4RxO6jiuNxMRzkpb2Axf8VCkmxfUWDWs4qWxf",
	"kgBySJpVyz0BtlhHn0b1uFOm1SnT6pRpdcq0OmVa3bNr+ZQTdcqJOuli/9k5UVPCR/zD1FzEz7LHJB/4",
	"/qD4cdcRJb1NPZObBRes0Wb8Dpon34y0FwWN4N1+x4d9QyOJDiEDe/aVKVkO8FeIqIlf0Z/PloqxP1hm",
	"qLKS8hR+29qNXyA8PhPNH78+c9DerDSM1jPic9EQloU957LcEROKHhFK/E7mVkDeyZpcA7KU/BL6u5dr",
	"7KFviAXizkt7RhKr4w+dqOuewXr2Zr3N78Obc0rgOyXwnRL4vgDTxqKU+aU+fw9XnaEBYa9HGjoNWS/+",
	"Zj/us1ggMuJ06ZTkeEH3ay0dwyLc3CnO/zOG+Emmuyhycrw6UoifPNnrTva6k73uZK872etOlZFOVsCT",
	"FfBkBTxZAU9WwJMV8O6sgB/Tcnf3T6ecbIMn2+DJUvJRM1Xiqz1/b3Wi/bkqxKqPZYtDDhkKY6ibkrDi",
	"lLLp5Qk/IxISHddByDodOU9pHSfy8qkYYj/MZ5qpK4/rtSpnT2ZrYyr95PycbemmKtlZLjfnUDfB9X8f",
	"5H652QCjCr+4kaNfHCn78MuH/wkAAP//wgcI2IZNAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
