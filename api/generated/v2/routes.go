// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
