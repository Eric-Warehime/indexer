// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
