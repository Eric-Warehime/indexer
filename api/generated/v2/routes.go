// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//xorNOsgIAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
